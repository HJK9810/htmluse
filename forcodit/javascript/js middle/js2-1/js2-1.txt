ECMAScript? : 자바스크립트의 표준
== ECMA-262
>> 최근버전? ES6 -> ES + 출시년도

모던자바스크립트? 현 시점에서 사용하기 적합한 번위 내에서 최신 버전의 표준을 준수하는 자바스크립트.

데이터타입
* 기본형?
>> 기본적인 타입들
1. Number : 숫자형
2. String : 문자형
3. Boolean : 참, 거짓
4. Null : 빈값
5. Undefined : 지정되지 않은 값
>> 특수한 타입들
6. Symbol : ES2015추가. 유일한 값을 만들때
7. BigInt : ES2020추가. 엄청 큰 숫자를 다룰때
* 참조형?
Object : 객체형

* Symbol형
const user = Symbol(심블값);
>> 설령 같은 값을 비교한다 할지라도 무조건 false값 반환.
* BigInt형
>> 9000조 이상의 '정수'의 경우 사용. 소수표현은 불가능.
console.log(9007199254740993n);
>> 9007199254740993n
console.log(BigInt(9007199254740993)); 
>> 9007199254740992n

typeof의 중요한점!!
1. typeof null == Object
2. typeof 함수명() == function

* Boolean형
>> false?(falsy값)
1. false
2. null3
3. NaN
4. Undefined
5. 0
6. ""
>> treu?(truthy값)
falsy값이외 전부.

AND우선순위 > OR 우선순위
AND연산 방식
1. 왼쪽이 true? 오른쪽값 리턴
2. 왼쪽이 false? 왼쪽값 리턴

OR연산 방식
1. 왼쪽이 true? 왼쪽값 리턴
2. 왼쪽이 false? 오른쪽값 리턴

Null병합 연산자?
A ?? B형식
1. 왼쪽이 null or undefined? 오른쪽값 리턴
2. 왼쪽이 null or undefined가 아니라면? 왼쪽값 리턴

함수 or 반복문등의 {}? >> 코드블록
let, const는 블록스코프를 가짐.

함수를 만드는것
1. 함수선언
function 함수이름 (파라미터) {
  함수내용.
}
>> 호이스팅 현상 발생.
>> 스코프 가능.
2. 함수표현식
const 함수이름 = function() {
  함수내용.
};
>> 호이스팅 불가능
>> 변수에 따라 스코프 결정.
>> 내부에서 자신을 사용할 경우 기명함수표현식 사용하는것이 좋음.
>> 기명함수표현식?
let 함수명 = function 기명함수명() {
  함수 내용.
  기명함수() << 변화값 등.
}

함수 만들때 주로 일관된 방식이 중요.
함수 선언쪽이 더 유효한 범위가 많으며 많이 사용됨.

즉시실행함수 == IIFE
(function () {
  함수내용.
})();
>> 추가적으로 함수 실행은 불가.
>> 주로 프로그램 초기화 기능에 사용 or 일회성 동작 or 리턴값을 바로 변수에 할당.

함수는 객체나 배열로 선언도 가능!!
콜백함수? 다른 함수에 호출되는 함수.
고차함수? 리턴값으로 배치된 함수.
>> 출력: 고차함수가 포함된 함수()();

argument : 함수 호출시 전달되는 파라미터.
파라미터의 기본값? undefined 단, 할당 연산자로 기본값을 줄 경우 해당 값이 기본값 설정.
argument가 하나라도 생략시 보통 파라미터 기본 순서 그대로 전달. 즉, 생략 가능한 파라미터는 기본적으로 오른쪽에 전달할것!
함수 내부에 arguments 객체 사용시 호출한 모든 argument사용 가능.
>> 파라미터를 arguments로 하거나 변수 이름을 arguments 하는것은 피해야 함.
rest 파라미터 : (...args) arguments객체를 사용하지 않고 args라는 배열로 나머지 파라미터를 저장, 전달. 일반 파라미터와 병행해서 사용 가능.

Arrow function : 익명함수. 함수를 간결하게 만들어줌.
const 함수명 = (파라미터) => {
  함수내용.
}
or
const 함수명 = 파라미터 => 리턴값.
단, 파라미터가 2개 이상 or 없을경우에는 생략불가능.
함수 내용이 리턴값 하나일 경우에는 { return }; 생략가능.
리턴값 객체일경우 생략 불가능. 이 경우에는 객체를 ()로 감싸면 가능.
arguments객체 사용 불가능!!
this선언시 해당 함수가 선언되기 직전의 this값을 가져옴.