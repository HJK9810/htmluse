문장인 표현식 : 변수에 할당되는 할당식등. ;으로 마무리.
표현식이 아닌 문장 : 조건문이나 반복문. {}로 마무리.

조건연산자(상황연산자)
* 조건식 ? 참 표현식 : 거짓 표현식;
>> 조건에 따라 변수나 반복문 추가 불가능.

spread구문 : 하나의 구문값을 개별적으로 하나하나 펼치는 '개념' 즉, 하나의 값이 아님!!
console.log(...배열명);
== console.log(배열값들);

배열 복사(주소값이 아니라 내용 그대로 복사)
1. 복새배열.splice()
2. [...복사배열, 추가 복사배열 or push값등.]

객체 표현시, value를 변수로 사용할때,
프로퍼티네임과 value변수 이름이 동일할 경우, 하나만 사용 가능.
객체내부 함수표현시? 함수명() {내용}, 로 축약가능.
프로퍼티네임 : ['a' + 'b'] or [변수명] or [함수명()] 사용가능
>> 결과? 'ab', 변수값, 함수값

** 옵셔널 체이닝 연산자(ES2020버전)
(user.cat === null || user.cat === undefined) ? undefined : user.cat.name
== user.cat?.name
>> user.cat의 값이 null or undefined가 아니라면? 다음 프로퍼티 리턴. 맞다면? undefined 반환.

구조분해(destructuring)
>> 배열
const [각 할당 변수들] = 배열명
배열길이와 할당 변수의 수가 동일할 필요는 없다.
가장 마지막 변수의 앞에 ...를 붙일경우 rest파라미터가 됨.
배열길이가 짧으면 undefined, 기본값 삽입 가능.
* 변수 교환시?
[a, b] = [b, a]; 로 간략화.
>> 객체
const {각 프로퍼티네임과 동일한 이름의 할당 변수들} = 객체명
if 프로퍼티네임과 다른 변수명을 선언하고 싶을 경우?  프로포티네임: 변수명
프로퍼티네임이 변수명으로 사용 불가능할경우, 반드시 새 변수명 할당!!!
>> 함수
파라미터에 해당 문법 사용시, 함수 전달을 배열로 전달받을수 있음.
객체또한 마찬가지. 전달받아 바로 사용 가능.
-> html dom객체 사용시의 event 객체 사용시에 사용가능.
즉, event -> {target} -> {target : {classList}}

에러객체
const error = new TypeError(에러 발생시 나오는 문자.);
throw error : 생성한 에러객체 발생시키는것.

자주 발생하는 에러
1. 존재하지 않는 변수 사용
2. 타입 에러
3. syntax에러

try catch문
try {
  동작코드.
} catch (error) {
  에러 발싱시 동작형 코드.
}
error파라미터? 발생한 에러객체 전달.
console.error(error); : 보통 보여주는 에러메세지 형태로 출력.
finally? try catch이후에 에러 상관없이 무조건적으로 실행할 코드를 작성.